# 第一章：风格

人们看到最好的作家有时并不理会修辞学的规则。还好，当他们这样做虽然付出了违反常规的代价，读者还经常能从句子中发现某些具有补偿性的价值。除非作者自己也明确其做法的意思，否则最好还是按规矩做。（William Strunk 和 E.B White，《风格的要素》）



## 1.1 名字

1.  **一个名字应该是非形式的、简练的、易记忆的**。如果可能的话，最好是能够拼读的。许多信息来自上下文和作用域。**一个变量的作用域越大，它的名字所携带的信息就应该越多。**

2.  **全局变量使用具有说明性的名字，局部变量使用短名字**。给每个全局变量声明附一个简短的注释。

   ```c
   int npending = 0;   //current length of input queue
   ```

   类似地，全局函数、类和结构体也应该有说明性的名字，以表明它们在程序里扮演的角色。相反，对局部变量使用短名字就够了。如，按常规方式i，j用作循环变量；p，q用作指针；s，t用作字符串。

3.  **命名保持一致性**。相关的东西应该以相关的名字，以说明之间的关系和差异。如下例：

   ```java
   class UserQueue {
       int noOfItemsInq, frontOfTheQueue, queueCapacity;
       public int noOfUsersInQueue() {...}
   }
   ```

   **上述代码存在的问题有**：

   A.  “队列（queue）” 分别在名字里分别被写为Q、Queue和queue。

   B. 由于只能在类型UserQueue中访问，因为存在上下文，所以类成员的名字不必提到队列。即`queue.queueCapacity`显得十分多余。

   **改写后的代码为**：

   ```java
   class UserQueue {
       int nitems, front, capacity;
       public int nusers() {...}
   }
   ```

   另外，还可以继续改进：items和nusers实际上是同一种东西，同样的东西应该使用同一个概念。

4.  **函数采用动作性的名字**。函数名应当采用动作性的名词，后面可以跟着名词：

   ```c
   now = data.getTime();
   putchar('\n');
   ```

5.  **对返回布尔类型值（真或假）的函数命名，应当清楚地反应其返回值的情况**。`if (checkoctal(c)) ...`  就没有 `if (isoctal(c)) ...`  好，前者没有指明什么时候返回真。另外，要避免的一种情况是，名字具有正确的含义而对应的实现却是其他的东西。如下例，函数 getIndex 如果找到了有关对象，就返回 0到 nTable-1之间的一个值，否则返回nTable的值。而实现恰恰相反。

   ```java
   public boolean inTable(Object obj) {
       int j = this.getIndex(obj);
       return (j == nTable);
   }
   ```



## 1.2 表达式和语句

1. **用缩进显示程序结构**。

2. **使用表达式的自然形式**。表达式应该写得能大声念出来。含有否定运算符的的条件表达式比较难理解，如下例：

   ```c
   if (!(block_id < actblks) || ！(block_id >= unblocks)) ...
   ```

   两个测试中都用到否定，应该改变关系运算符的方向，是测试编程肯定的：

   ```c
   if ((block_id >= actblks) || (block_id < unblocks)) ...
   ```

3.  **加括号消除二义性**。在混合使用互相无关的运算符的时候，多写几个括号是个好主意。

4. **“？：” 适用于短的表达式**。程序员的目标应该是写出最清晰的代码而不是最巧妙的代码，另外，清晰性并不等于简短。有些结构总是引诱人们去滥用。“ ? : ” 便属于这一类，如下例。

   ```
   child = (!LC && !RC ) ? 0 : (!LC ? RC : LC);
   ```

   如果不追踪表达式的每一条路径，很难弄清它到底是在做什么。修改后的虽然更长，但清晰得多：

   ```c
   if (LC ==0 && RC == 0)
       child = 0;
   else if (LC == 0)
       child = RC;
   else 
       child = LC;
   ```

5. **当心副作用**。如 `i++ `这类运算符。如下例的使用就极易出错。

   ```c
   str[i++] = str[i++] = ' ';
   ```

   

## 1.3 一致性和惯用法

1.  **解决“悬空的else”问题**。注意加上花括号。

2.  如果处理的不是自己写的程序（使用开源项目等），**注意保持程序原有的风格**。

3.  for 循环和while循环使用时遵照惯用方式。一致性地使用习惯用法有一个好处是使非标准的循环很容易被注意到，易于检查程序中的错误。

4.  **绝不要使用gets函数**，因为无法限制它由输入处读取的内容长度，这通常会带来安全性的问题。因此使用fgets会更好。

5.  strlen求出的值没有计入字符串结尾的 ' \0 ' 字符，因此在使用malloc 和 strcpy复制字符串时，应多分配一个字符的空间。

6.  **在实际程序中，对于malloc、realloc、strdup及任何涉及到存储分配的函数，都要对其返回值做检查**。

7.  用 `else-if` 表示多路选择。应把所有的else垂直对齐，而不是分别让每个else与对应的if对齐。形式如下：

   ```c
   if (condition1)
       statement1;
   else if (condition2)
       statement2;
   else if (condition3)
       statement3;
   else 
       default-statement;
   ```

   如果不存在默认动作，尾随的else部分就可以没有。**另一个更好的办法的是利用它给出一个错误信息，以帮助捕捉“不可能发生”的情况。**

8. **case语句最后都应该写一个break，如果偶尔有例外，一定要加上注释**。



## 1.4 函数宏

使用函数宏的根本理由就是执行效率：宏可以避免函数调用的开销。实际上，即使是在C语言刚诞生时（那时候机器十分慢，函数调用的开销也特别大），这个理由也是很脆弱的，到今天它更无足轻重了。有了新型的机器和编译程序，函数宏的缺点远远超过它带来的好处。

函数宏最常见的一个严重问题是：**如果一个参数在定义中多次出现，它就可能会被多次求值**，如下例会两次读取字符：

```c
#define issupper(c) ((c) >= 'A' && (c) <= 'Z')
while (issupper(c = getchar())) 
    ...
```

宏是通过文本替代来实现的，因此如果一定要使用宏，**要给宏的体和参数都加上括号**。但是，即使实在宏定义里完全加上括号，也不可能解决前面所提到的多次求值问题。



## 1.5 神秘的数

神秘的数包括各种常数、数组的大小、字符的位置、变换因子以及在程序中出现的其他以文字形式出现的数值。

1. **给神秘的数起个名字**。下面是一些反例：

   ```c
   fac = lim / 20;
   for (int i = 0; col = 0; i < 27; i++, j++){...}
   draw(23, 2, ' ');
   ```

2. **把数定义为常数，不要定义为宏**。

3. **利用语言去计算对象的大小**。不要对任何数据类型使用显式写出的大小。如应使用`sizeof(int)` 而不是2或者4。



## 1.6 注释

1. 最好的注释是简洁地点明程序的突出特征，或是提供一种概览帮助别人理解程序。**不要大谈明显的东西**。
2. **注释应该提供那些不能一下子从代码中看到的东西，或者是把那些散布在许多代码里的信息收集到一起**。当那些难以捉摸的事情发生时，注释可以帮助澄清情况。
3. **给函数和全局数据加注释**。对于函数、全局变量、常数定义、结构体和类的域等，以及任何其他加上简短说明就可以帮助理解的内容都应该加上注释。
4. 有些代码原本可能非常复杂，可能是因为算法本身很复杂的原因，这种情况下，用一段注释指明参考文献对读者也很有帮助。
5. 不要注释差的代码，重写它！
6. **不要与代码相矛盾，代码更新时，注释也要跟着更新**。



## 1.7 总结

本章谈论的主要问题是程序设计的风格：具有说明性的文字、清晰的表达式、直截了当的控制流、可读的代码和注释，以及在追求这些内容时一致地使用某些规则和惯用法的重要性。在风格上煞费苦心的的理由是：书写良好的代码更容易阅读和理解，几乎也可以保证其中的错误更少。好风格应该成为一种习惯。如果在开始写代码时就关心风格问题，如果花时间去审视和改进它，这将逐渐养成一种好的编程习惯。



**补充阅读：《编程精粹》、《代码大全》、《C专家编程》**